/*! For license information please see signal.0.1.0.min.js.LICENSE.txt */
var signal;(()=>{"use strict";var e={d:(r,o)=>{for(var t in o)e.o(o,t)&&!e.o(r,t)&&Object.defineProperty(r,t,{enumerable:!0,get:o[t]})},o:(e,r)=>Object.prototype.hasOwnProperty.call(e,r),r:e=>{"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})}},r={};e.r(r),e.d(r,{Signal:()=>j});var o=Object.defineProperty,t=(e,r,t)=>(((e,r,t)=>{r in e?o(e,r,{enumerable:!0,configurable:!0,writable:!0,value:t}):e[r]=t})(e,"symbol"!=typeof r?r+"":r,t),t),n=(e,r)=>{if(Object(r)!==r)throw TypeError('Cannot use the "in" operator on this value');return e.has(r)},u=(e,r,o)=>{if(r.has(e))throw TypeError("Cannot add the same private member more than once");r instanceof WeakSet?r.add(e):r.set(e,o)},i=(e,r,o)=>(((e,r,o)=>{if(!r.has(e))throw TypeError("Cannot access private method")})(e,r),o);function d(e,r){return Object.is(e,r)}let c=null,s=!1,l=1;const a=Symbol("SIGNAL");function p(e){const r=c;return c=e,r}const h={version:0,lastCleanEpoch:0,dirty:!1,producerNode:void 0,producerLastReadVersion:void 0,producerIndexOfThis:void 0,nextProducerIndex:0,liveConsumerNode:void 0,liveConsumerIndexOfThis:void 0,consumerAllowSignalWrites:!1,consumerIsAlwaysLive:!1,producerMustRecompute:()=>!1,producerRecomputeValue:()=>{},consumerMarkedDirty:()=>{},consumerOnSignalRead:()=>{}};function f(e){if(s)throw new Error(typeof ngDevMode<"u"&&ngDevMode?"Assertion error: signal read during notification phase":"");if(null===c)return;c.consumerOnSignalRead(e);const r=c.nextProducerIndex++;C(c),r<c.producerNode.length&&c.producerNode[r]!==e&&N(c)&&y(c.producerNode[r],c.producerIndexOfThis[r]),c.producerNode[r]!==e&&(c.producerNode[r]=e,c.producerIndexOfThis[r]=N(c)?g(e,c,r):0),c.producerLastReadVersion[r]=e.version}function v(e){if((!N(e)||e.dirty)&&(e.dirty||e.lastCleanEpoch!==l)){if(!e.producerMustRecompute(e)&&!function(e){C(e);for(let r=0;r<e.producerNode.length;r++){const o=e.producerNode[r],t=e.producerLastReadVersion[r];if(t!==o.version||(v(o),t!==o.version))return!0}return!1}(e))return e.dirty=!1,void(e.lastCleanEpoch=l);e.producerRecomputeValue(e),e.dirty=!1,e.lastCleanEpoch=l}}function w(e){if(void 0===e.liveConsumerNode)return;const r=s;s=!0;try{for(const r of e.liveConsumerNode)r.dirty||m(r)}finally{s=r}}function m(e){var r;e.dirty=!0,w(e),null==(r=e.consumerMarkedDirty)||r.call(e,e)}function g(e,r,o){var t;if(S(e),C(e),0===e.liveConsumerNode.length){null==(t=e.watched)||t.call(e.wrapper);for(let r=0;r<e.producerNode.length;r++)e.producerIndexOfThis[r]=g(e.producerNode[r],e,r)}return e.liveConsumerIndexOfThis.push(o),e.liveConsumerNode.push(r)-1}function y(e,r){var o;if(S(e),C(e),typeof ngDevMode<"u"&&ngDevMode&&r>=e.liveConsumerNode.length)throw new Error(`Assertion error: active consumer index ${r} is out of bounds of ${e.liveConsumerNode.length} consumers)`);if(1===e.liveConsumerNode.length){null==(o=e.unwatched)||o.call(e.wrapper);for(let r=0;r<e.producerNode.length;r++)y(e.producerNode[r],e.producerIndexOfThis[r])}const t=e.liveConsumerNode.length-1;if(e.liveConsumerNode[r]=e.liveConsumerNode[t],e.liveConsumerIndexOfThis[r]=e.liveConsumerIndexOfThis[t],e.liveConsumerNode.length--,e.liveConsumerIndexOfThis.length--,r<e.liveConsumerNode.length){const o=e.liveConsumerIndexOfThis[r],t=e.liveConsumerNode[r];C(t),t.producerIndexOfThis[o]=r}}function N(e){var r;return e.consumerIsAlwaysLive||((null==(r=null==e?void 0:e.liveConsumerNode)?void 0:r.length)??0)>0}function C(e){e.producerNode??(e.producerNode=[]),e.producerIndexOfThis??(e.producerIndexOfThis=[]),e.producerLastReadVersion??(e.producerLastReadVersion=[])}function S(e){e.liveConsumerNode??(e.liveConsumerNode=[]),e.liveConsumerIndexOfThis??(e.liveConsumerIndexOfThis=[])}function T(e){if(v(e),f(e),e.value===I)throw e.error;return e.value}const O=Symbol("UNSET"),x=Symbol("COMPUTING"),I=Symbol("ERRORED"),b={...h,value:O,dirty:!0,error:null,equal:d,producerMustRecompute:e=>e.value===O||e.value===x,producerRecomputeValue(e){if(e.value===x)throw new Error("Detected cycle in computations.");const r=e.value;e.value=x;const o=function(e){return e&&(e.nextProducerIndex=0),p(e)}(e);let t;try{t=e.computation.call(e.wrapper)}catch(r){t=I,e.error=r}finally{!function(e,r){if(p(r),e&&void 0!==e.producerNode&&void 0!==e.producerIndexOfThis&&void 0!==e.producerLastReadVersion){if(N(e))for(let r=e.nextProducerIndex;r<e.producerNode.length;r++)y(e.producerNode[r],e.producerIndexOfThis[r]);for(;e.producerNode.length>e.nextProducerIndex;)e.producerNode.pop(),e.producerLastReadVersion.pop(),e.producerIndexOfThis.pop()}}(e,o)}r!==O&&r!==I&&t!==I&&e.equal.call(e.wrapper,r,t)?e.value=r:(e.value=t,e.version++)}};function E(){return f(this),this.value}function W(e,r){!1!==(null==c?void 0:c.consumerAllowSignalWrites)||function(){throw new Error}(),e.equal.call(e.wrapper,e.value,r)||(e.value=r,function(e){e.version++,l++,w(e)}(e))}const R={...h,equal:d,value:void 0},k=Symbol("node");let P,M,L;var j,A,V,D,q,G,U,$,_,z,B;A=j||(j={}),V=k,D=new WeakSet,P=e=>n(D,e),A.State=class{constructor(e,r={}){u(this,D),t(this,V);const o=function(e){const r=Object.create(R);r.value=e;const o=()=>(f(r),r.value);return o[a]=r,o}(e)[a];if(this[k]=o,o.wrapper=this,r){const e=r.equals;e&&(o.equal=e),o.watched=r[A.subtle.watched],o.unwatched=r[A.subtle.unwatched]}}get(){if(!P(this))throw new TypeError("Wrong receiver type for Signal.State.prototype.get");return E.call(this[k])}set(e){if(!P(this))throw new TypeError("Wrong receiver type for Signal.State.prototype.set");if(s)throw new Error("Writes to signals not permitted during Watcher callback");W(this[k],e)}},q=k,G=new WeakSet,M=e=>n(G,e),A.Computed=class{constructor(e,r){u(this,G),t(this,q);const o=function(e){const r=Object.create(b);r.computation=e;const o=()=>T(r);return o[a]=r,o}(e)[a];if(o.consumerAllowSignalWrites=!0,this[k]=o,o.wrapper=this,r){const e=r.equals;e&&(o.equal=e),o.watched=r[A.subtle.watched],o.unwatched=r[A.subtle.unwatched]}}get(){if(!M(this))throw new TypeError("Wrong receiver type for Signal.Computed.prototype.get");return T(this[k])}},(U=A.subtle||(A.subtle={})).untrack=function(e){let r,o=null;try{o=p(null),r=e()}finally{p(o)}return r},U.introspectSources=function(e){var r;if(!M(e)&&!L(e))throw new TypeError("Called introspectSources without a Computed or Watcher argument");return(null==(r=e[k].producerNode)?void 0:r.map((e=>e.wrapper)))??[]},U.introspectSinks=function(e){var r;if(!M(e)&&!P(e))throw new TypeError("Called introspectSinks without a Signal argument");return(null==(r=e[k].liveConsumerNode)?void 0:r.map((e=>e.wrapper)))??[]},U.hasSinks=function(e){if(!M(e)&&!P(e))throw new TypeError("Called hasSinks without a Signal argument");const r=e[k].liveConsumerNode;return!!r&&r.length>0},U.hasSources=function(e){if(!M(e)&&!L(e))throw new TypeError("Called hasSources without a Computed or Watcher argument");const r=e[k].producerNode;return!!r&&r.length>0},$=k,_=new WeakSet,z=new WeakSet,B=function(e){for(const r of e)if(!M(r)&&!P(r))throw new TypeError("Called watch/unwatch without a Computed or State argument")},L=e=>n(_,e),U.Watcher=class{constructor(e){u(this,_),u(this,z),t(this,$);let r=Object.create(h);r.wrapper=this,r.consumerMarkedDirty=e,r.consumerIsAlwaysLive=!0,r.consumerAllowSignalWrites=!1,r.producerNode=[],this[k]=r}watch(...e){if(!L(this))throw new TypeError("Called unwatch without Watcher receiver");i(this,z,B).call(this,e);const r=this[k];r.dirty=!1;const o=p(r);for(const r of e)f(r[k]);p(o)}unwatch(...e){if(!L(this))throw new TypeError("Called unwatch without Watcher receiver");i(this,z,B).call(this,e);const r=this[k];C(r);let o=[];for(let t=0;t<r.producerNode.length;t++)e.includes(r.producerNode[t].wrapper)&&(y(r.producerNode[t],r.producerIndexOfThis[t]),o.push(t));for(const e of o){const o=r.producerNode.length-1;if(r.producerNode[e]=r.producerNode[o],r.producerIndexOfThis[e]=r.producerIndexOfThis[o],r.producerNode.length--,r.producerIndexOfThis.length--,r.nextProducerIndex--,e<r.producerNode.length){const o=r.producerIndexOfThis[e],t=r.producerNode[e];S(t),t.liveConsumerIndexOfThis[o]=e}}}getPending(){if(!L(this))throw new TypeError("Called getPending without Watcher receiver");return this[k].producerNode.filter((e=>e.dirty)).map((e=>e.wrapper))}},U.currentComputed=function(){var e;return null==(e=c)?void 0:e.wrapper},U.watched=Symbol("watched"),U.unwatched=Symbol("unwatched"),signal=r})();